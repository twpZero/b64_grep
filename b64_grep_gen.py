#!/usr/bin/python3

import base64

"""
When used as a program, it generates the 3 possible B64 Permutations for a given cleartext.
Input can be given as argument or via stdin (convenient for POSIX bash uses)
Output is designed to be feed into a regex engine, accordingly each possible value is separated by a pipe "|".


Can also be used as a toolbox in other python scripts.

~~~CONTEXT~~~
    Searching strings in base64 encoded data doesn't require decoding the said data.
    However base 64 convert an input of 3 char at a time, to a 4 char output.
        abc -> YWJj
            a will influence byte[0] and byte[1] (YW)
            b will influence byte[1] and byte[2] (WJ)
            c will influence byte[2] and byte[3] (Jj)
        
    Shifting the first letter to the right will change the output.
    
       abc -> YWJj
       zab(c)  -> emFi(Yw==)
       zza(bc) -> enph(YmM=)
    
    So there are 3 possible b64 depending of the offset of the starting char (a), those are caled "permutations".
    Note that shift right produces some garbage output which needs to be removed.
    
    In the same manner if the converted text is smaller than 3 caracters "\x00" padding is added (showing up as "=").
        "   " -> AAA=
        "c  " -> Yw==
        "bc " -> YmM=
        // " " is used to represent 'Null'     

    As stated above, input input_byte[1] and input_byte[2], influence output_bytes[1], output_bytes[2],output_bytes[3].
        So when shifting right the input by 1 char, at the last round of the conversion, output_byte[1],output_byte[2],output_byte[3] must be dropped.
        So when shifting right the input by 2 char, at the last round of the conversion, output_byte[2],output_byte[3] must be dropped.
        
This program was dev using the follwing resources :
    @Resource https://www.leeholmes.com/searching-for-content-in-base-64-strings/
    @Resource https://en.wikipedia.org/wiki/Base64
    @Resource https://yara.readthedocs.io/en/stable/writingrules.html?highlight=base64#base64-strings

"""

def str_b64encode(text,encoding="utf8"):
    """
    Performs b64 encoding using str arg.
    Returns str value

    @Arg encoding defaults to "utf8"
    #Note encoding accepts standards bytes encoding values 
    @See bytes
    @Use base64.b64encode
    """
    return base64.b64encode(bytes(text,encoding)).decode()


def alternative_b64encode(text,encoding="utf8"):
    """ 
    Generates an str array containing the 3 possible b64 permutations for the specified (clear)text.
    @Note encoding argument is handled by str_b64encode

    @Arg encoding defaults to "utf8"

    @See str_b64encode
    @Use str_b64encode

    @Resource https://www.leeholmes.com/searching-for-content-in-base-64-strings/
    @Resource https://en.wikipedia.org/wiki/Base64
    @Resource https://yara.readthedocs.io/en/stable/writingrules.html?highlight=base64#base64-strings
    """
    return [str_b64encode("-"*decal+text,encoding)[[0,2,3][decal]:[-3,-3,-3][decal]] for decal in range(3)]


def gen_b64_regex(text,encoding="utf8"):
    """
    Concatenes with "|" the str array containing the 3 possible b64 permutations generated by alternative_b64encode.
    @Note encoding argument is handled by str_b64encode

    @Arg encoding defaults to "utf8"
    @See str_b64encode

    @Use str_b64encode
    @Use alternative_b64encode
    
    """
    return("|".join(alternative_b64encode(text,encoding)))


if __name__ == '__main__':
    import argparse
    
    parser = argparse.ArgumentParser(description='When used as a program, it generates the 3 possible B64 Permutations for a given cleartext.\nInput can be given as argument or via stdin (convenient for POSIX bash uses)\nOutput is designed to be feed into a regex engine, accordingly each possible value is separated by a pipe "|".\n\n',formatter_class=argparse.RawTextHelpFormatter)
    parser.add_argument('text', metavar='text', type=str, nargs="?", help='Text to encode')
    parser.add_argument('encoding', metavar='encoding', type=str, nargs="?", help='Encoding to use', default="utf8")
    parser.add_argument('-e', metavar='encoding', type=str, nargs="?", help='Encoding to use', dest="enc")
    args = parser.parse_args()

    if(args.enc != None):
        args.encoding = args.enc

    try:
        import sys
        if(args.text != None):
            print(gen_b64_regex(args.text,args.encoding))
        else:
            line = sys.stdin.readline()
            while( line != '' and line != '\n' ):
                line = line.replace("\n","")
                print(gen_b64_regex(line,args.encoding))
                line = sys.stdin.readline()
        exit(0)
    except Exception as ex:
        sys.stderr("Error ! {}({})".format(ex,ex.message))
        exit(1)